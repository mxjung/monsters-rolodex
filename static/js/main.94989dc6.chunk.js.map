{"version":3,"sources":["Components/card/card.component.jsx","Components/card-list/card-list.component.jsx","Components/search-box/search-box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","key","SearchBox","placeholder","handleChange","type","onChange","App","e","setState","searchField","target","value","console","log","state","fetch","then","Response","json","users","this","filteredMonsters","filter","toLowerCase","includes","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"uVAIaA,G,kBAAO,SAAAC,GAAK,OACvB,yBAAKC,UAAU,kBACb,yBACEC,IAAI,UACJC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BAEL,4BAAKL,EAAMI,QAAQE,MACnB,2BAAIN,EAAMI,QAAQG,UCDTC,EAAW,SAAAR,GAAK,OAC3B,yBAAKC,UAAU,aACZD,EAAMS,SAASC,IAAI,SAAAN,GAAO,OACzB,kBAAC,EAAD,CAAMO,IAAKP,EAAQC,GAAID,QAAWA,QCL3BQ,G,MAAY,SAAC,GAAD,IAAEC,EAAF,EAAEA,YAAaC,EAAf,EAAeA,aAAf,OACrB,2BACAb,UAAU,SACVc,KAAK,SACLF,YAAcA,EACdG,SAAUF,MCiGCG,E,YApFb,aAAe,IAAD,8BACZ,+CAqCFH,aAAe,SAAAI,GACb,EAAKC,SAAS,CAAEC,YAAaF,EAAEG,OAAOC,OAAS,kBAC7CC,QAAQC,IAAI,EAAKC,UArCnB,EAAKA,MAAQ,CACXhB,SAAU,GACVW,YAAa,IALH,E,iFAaO,IAAD,OAElBM,MAAM,8CACHC,KAAK,SAAAC,GAAQ,OAAIA,EAASC,SAC1BF,KAAK,SAAAG,GAAK,OAAI,EAAKX,SAAS,CAAEV,SAAUqB,Q,+BA2BpC,MAG2BC,KAAKN,MAA/BhB,EAHD,EAGCA,SAAUW,EAHX,EAGWA,YACZY,EAAmBvB,EAASwB,OAAO,SAAA7B,GAAO,OAC9CA,EAAQE,KAAK4B,cAAcC,SAASf,EAAYc,iBAGlD,OACE,yBAAKjC,UAAU,OACb,gDACA,kBAAC,EAAD,CACEY,YAAY,kBACZC,aAAciB,KAAKjB,eAErB,kBAAC,EAAD,CAAUL,SAAUuB,S,GA9DVI,aCXEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMrB,KAAK,SAAAsB,GACjCA,EAAaC,iB","file":"static/js/main.94989dc6.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./card.styles.css\";\r\n\r\n// Giving a different number in the URL gives us a unique monster image\r\nexport const Card = props => (\r\n  <div className=\"card-container\">\r\n    <img\r\n      alt=\"monster\"\r\n      src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`}\r\n    />\r\n    <h2>{props.monster.name}</h2>\r\n    <p>{props.monster.email}</p>\r\n  </div>\r\n);\r\n","import React from \"react\";\r\nimport \"./card-list.style.css\";\r\nimport {Card} from '../card/card.component';\r\n\r\n// whatever that goes between <CardList name=\"Max\"></CardList> is a children of the input, props\r\n\r\n// We want components to take care of the rendering, but the components should not dictate how this component looks/create them - we will create a new component to do that, a card component\r\n\r\n// Key is used to help react distinguish between our cards\r\n\r\nexport const CardList = props => (\r\n  <div className=\"card-list\">\r\n    {props.monsters.map(monster => (\r\n      <Card key={monster.id} monster = {monster}/>\r\n    ))}\r\n  </div>\r\n);\r\n","import React from 'react';\r\n\r\nimport './search-box.styles.css';\r\n\r\n// Functional Components - Do not have access to state (unlike our classes) because they don't have access to a constructor that extends app supers. A functional component just renders some html\r\n\r\n// SO if you 1) no need of state 2) don't need life cycle methods - then just use functional components\r\n\r\nexport const SearchBox = ({placeholder, handleChange}) => (\r\n    <input \r\n    className='search'\r\n    type=\"search\" \r\n    placeholder= {placeholder}\r\n    onChange={handleChange}\r\n   />\r\n);","import React, { Component } from \"react\";\n// 1. grab component from react\n//import logo from \"./logo.svg\";\nimport \"./App.css\";\n\n//9. we want to import the components we build\nimport { CardList } from \"./Components/card-list/card-list.component\";\nimport { SearchBox } from \"./Components/search-box/search-box.component\";\n\n// function App() {\n//   return (\n//     <div className=\"App\">\n//     </div>\n//   );\n// }\n\n// 2. Instead of the function app(), we conver this to a class: - you can have function or class.\n// 3. let's say we want a button below <p>. With class component, we get this thing called the state, state is a js object with properties that we can get inside our class.\n// 4. Anything between { } is JS, and we can tell <p> to be the state\n// 5. On every html element, we have access to onClick propoerty that gets called whenever it gets clicked, where we can change the state.\n// 6. In JSX, className is not JS class (nor is it like classes in HTML), its a JSX attribute\n// 7. We change state by calling setState, and not this.state.string because of the unidirectional data flow of React. We can't change state without calling setState.\n\nclass App extends Component {\n  // What does class App extends Component mean? Component is a react library. WE could have done class app extends React.Component. Whatever functionality exists in React.Component, i want that functionality in our components like render. Super() helps us with this by called react.Compoents constructor() like from past lessons on classes.\n\n  constructor() {\n    super();\n    // calls react.Component to grab its functionality/attributes.\n    this.state = {\n      monsters: [],\n      searchField: \"\"\n    };\n\n    // We have to set the context of our methods (the ones we write, like handleChange) in order for them to know the scope, of this. But instead of doing below, let's use arrow functions\n    //this.handleChange = this.handleChange.bind(this);\n  }\n\n  // Life Cycle methods: they are methods that get called in different stages of when this Component gets rendered. when this component mounts, or webpage is created, it calls whatever block of code we put insude componentDidMount\n  componentDidMount() {\n    // Make API request\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then(Response => Response.json())\n      .then(users => this.setState({ monsters: users }));\n  }\n\n  // 8. React wants us to have unique id when we run through the map (because react wants to know which html element we are changing), so we use unique keys - from course - \"Anytime you use the map() function inside of render, or you have a list of the same jsx elements one after another, they need a key attribute (and CRA will warn you about it if you miss it)\"\n\n  // Pass in monsters to the component\n\n  // input type=\"search\" where type is a built in functionality of input in html (well, jsx, but we treat it similarly to html) - visit SyntheticEvent. We want to fire my onChange whenever it changes. onChange has an element called target, which we want (e.target.value)\n\n  // if we have a console.log for this.state right after setState.searchField, we wont see the exact change taking place real time because setState is asynchronous - it will wait til other sychronous calls are made before executing. to see in our console what we are typing in, we will use another react solution, callback. Also note that the function is anonymous, we don't actually run the setState function within render()\n\n  //   <input\n  //   type=\"search\"\n  //   placeholder='search monsters'\n  //   onChange={e =>\n  //     this.setState({searchField: e.target.value}, () =>\n  //     console.log(this.state))}\n  //  />\n\n  // Let's write our own class method:\n  // arrow function allows react to know to bind this where the arrow function was defined. This is called lexical scoping\n  handleChange = e => {\n    this.setState({ searchField: e.target.value }, () =>\n      console.log(this.state)\n    );\n  };\n\n  render() {\n    // We will now filter the monsters array to select only the monsters the user is searching for. We will destructure, which allows us to pull properties off of an object and set them to const\n\n    const { monsters, searchField } = this.state; //we have destructured\n    const filteredMonsters = monsters.filter(monster =>\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n    );\n\n    return (\n      <div className=\"App\">\n        <h1>Monsters Rolodex</h1>\n        <SearchBox\n          placeholder=\"search monsters\"\n          handleChange={this.handleChange}\n        />\n        <CardList monsters={filteredMonsters}></CardList>\n      </div>\n    );\n  }\n  // render() {\n  //   return (\n  //     <div className=\"App\">\n  //       <header className=\"App-header\">\n  //         <img src={logo} className=\"App-logo\" alt=\"logo\" />\n  //         <p>{this.state.string}</p>\n  //         <button onClick={() => this.setState({string: 'Hello Andrei'})}>Change Text</button>\n  //         <a\n  //           className=\"App-link\"\n  //           href=\"https://reactjs.org\"\n  //           target=\"_blank\"\n  //           rel=\"noopener noreferrer\"\n  //         >\n  //           Learn React\n  //         </a>\n  //       </header>\n  //     </div>\n  //   );\n  // }\n}\n\nexport default App;\n\n// 190914 - we know that app() can return html, but react also allows us to create classes that can return html. We follow these steps (starting from 1):\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'))\n// reactDOM allows us to grab an element from HTML and insert App into it. \n;\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}